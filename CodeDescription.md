# I2C_parse
The Program has four functions -
main(), i2c_parse(), Parse_SCL_SDA(), GetHexFromBin().
Program begins with main() function where it will first check for command line arguments and expects a name of the text file needed to be parsed. If there are no command line arguments found it will ask for a file name.
Once file name is obtained, i2c_parse() function will be called where “ifstream infile” will be the first argument and “ofstream outfile” will be second argument.
In the i2c_parse() function, infile will attempt to open the file, upon fail to read it will display error respectively and exit the program. On successful attempt of opening the file, initial variables and flags are initialized to be used in the state-machine code flow.
Important Variables and Flags- 
int transactionCount=0; int masterRead=0; int masterWrite=0; int ackCount=0; int nackCount=0; char prev_scl=`1’; char prev_sda=`1’; char scl=`1’; char sda=`1’; bool StartStopFlag=false; bool ReadWriteFlag = false; bool addressReadFlag=false; bool dataReadFlag=false; bool AckFlag=false; bool NackFlag=false; string address, data1, data2; bool data1Received=false; bool data2Received=false; int count=1; int addressLength=7; int dataLength=8; string outputFileContent=””, string transactions=””;
In i2c_parse function, after initializing variables and flags we keep on reading the lines from the input file unit we reach to the ‘End of file’ (EOF).
We skip the header file and read the next line. Initial values of scl and sda are stored in prev_scl and prev_sda respectively. New values of scl and sda are obtained.
We check for starting condition where prev_scl==1 && prev_sda==1 && scl==1 and sda==0, if the condition is satisfied we change the flags, where we increment the transactionCount by 1, set StartStopFlag=true, addressReadFlag=true, AckFlag=false, dataReadFlag=false, data1Received=false, data2Received=false; and we continue the loop.
Again in the loop we read next line and store scl and sda in prev_scl and prev_sda, if starting condition is not met then we check if StartStopFlag==true, if true we check scl==1, if true then we check if addressReadFlag==true, if true then we proceed until address is read, and then we set addressReadFlag=false; ReadWriteFlag=true; and continue the loop.

Next we check if ReadWriteFlag==true, if true then we check if sda==1, if true we increment masterRead by  1 or-else we increment masterWrite by 1, then we set ReadWriteFlag=false, store scl and sda value in prev_scl and prev_sda, set AckFlag=true, NackFlag=false; and continue the loop.
Next we check if AckFlag==true, if true then we check whether it is Acknowledgement of Non-Acknowledgement, if scl==1 and sda==1, we consider it as Nack, and increment nackCount by 1, set NackFlag=true, data1Received=false; or-else we increment ackCount by 1, set dataReadFlag=true; data1Received=false.
Next we check if dataReadFlag==true, if true, we check for StartStopFlag, if condition is false, the we proceed to read the data. We check if data1Received==false then we proceed to append received data in data1 variable, once data is received we proceed to check whether or not second data is present or not. If present we proceed to read the data and store it in data2 variable. If StartStopFlag condition is met, we simply append the address and data to the transactions variable.
Upon reaching the end of the file we append the formatted string to outputFileContent. We append the required number of transactions happened, number of master reads/writes, number of Acknowledgements and Non-acknowledgements, and the actual transactions with address and received data in Hex Format.
